##### OSI7层协议
1.物理层：规定了物理设备的标准，作用是传输比特流，网卡工作在该层
2.数据链路层：将比特流组成帧，提供错误检测和纠正，交换机工作在该层
3.网络层：找到目标节点，将网络地址翻译为对应的为物理地址，并决定从发送方到接受方的路由路径，作用是传输数据报，需要关注IP协议，路由器在该层
4.传输层：解决主机间的数据传输，解决了传输质量的问题。OSI中最重要的一层，流量控制在该层，将较长的数据报分割。关注TCP和UDP协议
5.会话层：自动收发包和寻址，建立和管理应用程序之间的通信
6.表示层：数据按照网络能理解的方案进行格式化
7.应用层：规定发送方和接受方使用固定的消息头，旨在让用户更方便应用从网络中获得的数据，关注http协议

##### TCP/IP参考模型
1.物理层：以二进制形式在物理媒体之间进行传递
2.数据链路层：传输有地址的帧以及错误检测
3.网络层：为数据选择路由
4.传输层，提供端到端的接口
5.应用层：将OSI协议中的会话层、表示层、应用层整合

##### TCP的三次握手
###### TCP头部：

![image-20200505235656223](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200505235656223.png)

source Port    distination Port
源端口		目的地址端口
各占2字节

Sequence Number ：序列号，占4个字节，按顺序编号
ACK Number：确认号，占4个字节，期望收到对方下一个报文的第一个数据字节的序号
offset：数据偏移，由于头部有可选择字段，长度不固定，因此，offset指出TCP报文的数据，距离TCP报文的起始处有多远 
Reserved：保留域
TCPFlags:
	1.URG:紧急指针标志，1表示紧急指针有效，0表示紧急指针无效
	2.ACK:确认序号标志。为1则确认号有效，0表示序列号中不包含确认信息
	3.PSH:push标志，为1代表有push标志的数据，指示接受方在收到这个应用程序的数据后应尽快将数据发送给接收方，而不是在缓冲区排队
	4.RST:重置连接标志(Reset），用于重置由于主机崩溃或者其他原因而出现错误的连接，或者用于拒绝非法的报文段和连接请求
	5.SYN:同步序列号，用于建立连接过程。在连接过程SYN=1和ACK=0表示该字段没有使用捎带的确认域。使用了捎带的确认域的状态为SYN=1并且ACK=1
	6.FIN:finish标志，用于释放连接

window窗口：指的是滑动窗口的大小，发送端和接收端缓存的大小，以此控制发送端和接收端的速率，从而达到流量控制

checkSum：校验和，指的是奇偶校验，根据发送端报文头和报文数据以16位进行计算所得，由发送端计算和存储，并由接收端进行验证

urgent Pointer：紧急指针，只有当Flags中URG为1时候才有效，指出本报文中紧急数据的字节数。

TCP Options：可选项，其他的一些可选参数

![image-20200506000337102](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200506000337102.png)

###### 为什么要三次握手才能建立连接

为了初始化Sequence Number的初始值

建立SYN Cookie保证SYN不会因为SYN Flood攻击而造成SYN超时

保活机制防止建立连接后发生故障，达到保活次数后，地址被认定为不可达，连接中断



##### TCP4次挥手

挥手是为了终止连接，流程图如下：

![image-20200506222902970](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200506222902970.png)

MSL：最长报文段寿命

文字描述：

> 第一次挥手：客户端向服务端发送fin请求，FIN=1，seq=u，发送完之后进入FIN-WAIT1状态
>
> 第二次挥手：服务端向客户端发送确认，ACK=1，ack=u+1，发送完之后进入CLOSE-WAIT状态，客户端收到之后进入FIN-WAIT2状态
>
> 第三次挥手：服务端向客户端发送终止请求，即FIN=1,seq=w,之后进入LAST-ACK状态
>
> 第四次挥手：客户端向服务端发送确认信号，即ACK=1,ack=w+1,服务端收到之后直接进入CLOSED状态；客户端等待两个MSL(最长报文寿命)时间段之后，进入CLOSED状态。
>
> 之所以客户端要等大2MSL的时间，原因如下：
>
> 1.要确保对方有足够的时间收到ACK包（如果对方未收到ACK,则会处罚重传，即继续发送FIN信号，一来一回刚好为2MSL时间 ）
>
> 2.避免新旧连接混淆

###### 为什么要使用4次挥手断开连接呢

因为TCP是全双工的，所以发送方和接收方都需要FIN和ACK报文

###### 服务器出现大量CLOS_WAIT状态的原因：

对方关闭Socket连接，我方忙于读写，没有及时关闭连接

解决方法：1、检查代码，可能是程序未释放资源

2、检查配置，可能是处理的线程配置不合理

###### 查看tcp每种状态连接个数的语句：netstate -n | awk  '/^tcp/{++S[$NF]}END{for(a in s) print a,S[a]}'

##### UDP

![image-20200506232157093](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200506232157093.png)

##### UDP特点

- 面向非连接
- 不维护连接状态，支持多个客户端传输相同的消息
- 数据报头只有8个字节，额外开销少
- 吞吐量只受限于数据生成速率，传输速率及机器性能
- 尽最大努力交付，即不保证可靠交付，不需要维持复杂的连接状态表
- 面向报文，不对程序提交的报文数据进行拆分或者合并

##### TCP和UDP区别

1. TCP面向连接，UDP面向无连接
2. 可靠性
3. 有序性
4. TCP速度慢，UDP速度快
5. 量级：TCP重量级的，报文头20字节，UDP轻量级，报文头8字节

###### TCP滑动窗口

RTT和RTO

RTT：发送到收到一个ACK所需时间，时间差

RTO：重传时间间隔，预先算重传时间，超时时间，根据RTT计算

作用：保证TCP可靠性，保证TCP流控特性

##### HTTP主要特点

- 支持客户/服务器模式

- 简单快速

- 灵活

- 无连接（限制每次连接只处理一次请求），1.1是长连接（服务器需要等待一定时间才断开连接）
- 无状态 

##### HTTP请求结构：

![image-20200506235729748](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200506235729748.png)

##### HTTP响应结构：

![image-20200507000140505](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200507000140505.png)

##### 请求/响应的步骤

> - 客户端连接到web服务器
> - 客户端发送HTTP请求
> - 服务器接收请求并返回HTTP响应，Web服务器解析请求，定位请求资源
> - 释放TCP连接（若连接模式为close，则服务器主动关闭连接，客户端被动关闭连接，若keep-alive，服务器等待一定时间后关闭）
> - 客户端浏览器解析html

##### 在浏览器地址栏进入URL，按下回车之后经历了什么样的流程

> - DNS解析
> - TCP连接
> - 发送HTTP请求
> - 服务器对浏览器进行相应，并返回HTTP报文
> - 浏览器解析渲染页面
> - 连接结束

##### HTTP状态码

> - 1xx：指示信息---表示请求已接收，继续处理
> - 2xx：成功--表示请求已被成功接收、理解、接受
> - 3xx：重定向--要完成请求必须进行进一步的操作
> - 4xx：客户端错误--请求有语法错误或请求无法实现
> - 5xx：服务器错误--服务器未能实现合法的请求

##### 常见HTTP状态码

> - 200 OK：正常返回信息
> - 400 Bad Request：客户端请求有语法错误，不能被服务器所理解
> - 401 Unauthorized：请求未授权，这个状态码必须和WWW-Authenticate报头域一起使用
> - 403 Forbidden：服务器收到请求，但是拒绝提供服务
> - 404 Not Found：请求资源不存在，eg.输入了错误的URL
> - 500 Internal Server Error：服务器发生不可预期的错误
> - 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，比如连接池已满

##### GET请求和POST请求

> - HTTP报文层面：GET请求信息在URL中，POST请求在报文体里，相对安全一点
> - 数据库层面：GET符合幂等性（对数据的操作和多次操作的结果是一致的）和安全性（对数据库中的数据没有改变），POST不符合
> - 其他层面：GET请求可以被缓存、被存储，而POST不行

##### Cookie和Session的区别

> Cookie
>
> - Cookie是服务器给客户端发送的特殊信息，以文本的形式放在客户端
> - 客户端再次请求时，会把Cookie回发
> - 服务器接收后，会解析Cookie生成与客户端对应的内容
>
> Session
>
> - 服务器端的机制，在服务器保存的信息
> - 解析客户端请求并操作session id，按需保存状态信息
>
> Session实现方式
>
> - 使用Cookie来实现
>
>   ![image-20200507233125145](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20200507233125145.png)
>
> - 使用URL回写来实现：服务器在发送给浏览器的所有参数，都携带SessionId
>
> Tomcat是最开始同时使用了Cookie和URL回写两种，若客户端使用了Cookie，则URL回写不生效，否则使用URL回写

- Cookie存放在客户端，Session存放在服务器
- Session相比Cookie更安全，因为Cookie可能被改写
- Session会增加服务器的负担，若要减少服务器负担，应使用Cookie

##### HTTP和HTTPS的区别

HTTPS使用了SSL协议进行加密，更加安全

- HTTPS需要到CA申请证书，HTTP不需要
- HTTPS密文传输，HTTP明文传输
- 连接方式不同，HTTPS默认使用443端口，HTTP默认使用80端口
- HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全

##### HTTPS真的安全吗？

默认填充是HTTP，请求进行跳转，有被劫持的可能，使用HSTS

##### Soket

Soket是对TCP/IP协议的抽象，是操作系统对外提供的操作接口



